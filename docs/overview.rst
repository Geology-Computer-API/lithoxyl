Lithoxyl Overview
=================

The Lithoxyl approach to application instrumentation is
straightforward. First, write your code. Then, once you have half a
module or find yourself asking, "How long does this part take?" then
it's time to ``pip install lithoxyl``.

With Lithoxyl, logging and other instrumentations starts with wrapping
important parts of your application in microtransactions called
``Records``. Records can be created directly, but they are most often
created through ``Loggers``.

Let's take a look::

  import backend           # some convenient backend logic for brevity
  from log import app_log  # preconfigured Lithoxyl Logger

  def create_entry(name):
      with app_log.info('adding entry by name'):
          name = name.strip()
          backend.add_by_name(name)
      return True

As you can see, the transactionality of records translates well to
Python's :term:`with` context manager syntax. One benefit of this
approach is that a single line of logging code is able to record both
the start and end events. Even better is that there is no chance of
missing an exception if one is raised unexpectedly. For instance, if
*name* is not a string, and ``.strip()`` raises an ``AttributeError``,
then that exception is guaranteed to be recorded.

Records also support direct interaction. Arbitrary data can be added
to the record, with dictonary syntax. And while records finish with a
success status and autogenerated message if no exception is raised,
failures and exceptions can also be set manually::

  import backend
  from log import app_log

  def set_entry_state(name, state):
      with app_log.info('setting entry state') as rec:
          rec['name'] = name
          status = backend.STATE_MAP[state.lower()]
          success = backend.set_entry_state(name, state)
          if not success:
              rec.failure('set {name} status to {state} failed', state=state)
       return success

As seen above, records can also have a custom completion message,
which supports templating with new-style formatting syntax, using data
from within the record's data map (*name*), as well as arguments and
keyword arguments (*state*).

.. note::

   Even if message formatting fails, the log message will degrade
   gracefully. As a rule, Lithoxyl degrades gracefully, to minimize
   impact to your application's primary functionality.

Furthermore, in cases like this, where you want the whole function
logged, you can simply do::

  import backend
  from log import app_log

  @app_log.wrap('critical', inject_as='rec')
  def delete_entry(name, rec):
      try:
          ret = backend.delete_entry_by_name(name.strip())
      except backend.EntryNotFound:
          # log soft error, let other exceptions raise through
          log_rec.failure('no entry with name: {}', name)
          ret = False
      return ret

Note the decorator syntax, as well as the ability to inject the log
record as one of the arguments of the function. This reduces the
instrumentation's code footprint even further.

Small- to medium-sized applications can go pretty far with just one
Logger, but larger applications benefit from multiple. Loggers
generally correspond to an aspect of the system.

Records are used to generate messages and measurements through to any
number of ``Sinks``, which are responsible for persistence and
statistics, through log files, network streams, and much more.

Structured logging is a critical step for many applications. The
ability to parse and load logs opens up many new roads in debugging,
optimization, and system robustification.
